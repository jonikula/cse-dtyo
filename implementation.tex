% Implementation Chapter
The implementation of the prototype was done in 4 main phases, which are discussed in this chapter. First, some high-level requirements and objectives were identified with the customers representatives. Based on these high-level requirements as well as the example set by an existing open-source model-based testing tool, a proof of concept (PoC) implementation was created.


-- Desing refined and specified after first PoC.

-- Implementation.

-- Briefly on testing plan.


\section{Requirements specification}

\subsection{Product scope}
The software system will be a prototype of a model-based testing tool for the testers in ARM system testing team. It will be designed so that starting its use will be easy for the testers, requiring as little training as possible. It will include state-machine style modeling support, including relevant test selection criteria. 
The tool is designed so that it will be easily utilized as a part of the system testing teams existing tools. It will contain abstract interfaces for adapters used to generate the executable tests from abstract test cases generated by this tool. The software will be restricted to the abstract level of test case generation.

\subsection{Product perspective}
The tool developed for this thesis is a model-based testing tool designed to fit into the model-based testing process flow. It covers the first steps in the process: the model and the test case generator as well as an interface to enable use of test script generators which plug in to existing testing tools used by the organization.

\subsection{Product functionality, users and operating environment}
This section summarizes the major functions the software must perform or must let the the different actors perform through various use cases.

\subsubsection{Users and characteristics}
The normal user of the software is expected to be a test engineer in the ARM system testing team. They are expected to have basic skills in Python, experience in testing and formal modeling as well as a basic understanding of programming. 

The test engineer will be able to perform at least the following high-level use cases with the software. 

\begin{enumerate}
	\item Develop a model
	\item Maintain a model and related test suites
	\item Analyze requirements traceability matrix and coverage reports
	\item Add specific, custom test into the suite
\end{enumerate}  

-- Add brief descriptions of each use case

\subsubsection{Operating environment}
The main component of the tool will be a software application, which is usable in any modern operating system that has Python 2.7. The software is designed with a command line interface and so that it requires no external tools to be used. The tool will also need to be able to interact with current testing tools and adapters. 

\subsection{Design and implementation constraints}
There are very few constraints for this piece of software. Primarily it will need access to the file system to be able to generate test cases and read model files. The system also requires Python 2.7 or newer to run. The test case generation itself should not require access to internet or internal networks, but executing the test cases might require these. The tool should also be able to upload select parts of the files and data it generates into an online database. In addition to these minor constraints, the only major design constraint is the user interface. The command line interface needs to be taken into account in the design, as it places constraints on the usability of the system.

\subsection{User documentation}
All the major on minor functionalities will be documented in Markdown format in a GitHub repository, alogn with some easy-to-use tutorials and examples. UML documents describing the different parts of the system will be made available to the users as well as a part of this thesis.  

\subsection{Interfaces}
The interfaces required and presented by the tool are defined in this section. 

\subsubsection{User interfaces}
The tool is accessible to users through a command line interface, which uses simple, sharthand options to guide the functionality of the tool. The command flow should be split into two successive main branches, which can also be run in succession automatically. Several minor functionalities should be accessible along these two main flows.

\subsubsection{Hardware interfaces}
The tool is a pure software tool so it has no hardware interfaces. 

\subsubsection{Software interfaces}
The application is to be developed with Python 2.7 in mind, but support for Python 3 should be maintained where possible. The tool will use interfaces provided by Python to interface with the operating system and the file system when generating test cases, log files and reports. The tool should also have access to an online database via HTTP (described further in communications interfaces).

\subsubsection{Communications interfaces}
The application will use HTTP/HTTPS to communicate with an online database service.

\subsection{Other non-functional requirements}

\subsubsection{Performance requirements}
The performance of the system is largely related to user decision, as the size of the suite generated is directly related to the speed of the execution. In general, the application should not take more than a minute or two to generate a moderately sized test suite. Just in case, the tool should report it's progress in the command line so that the user can follow the execution. The tool should not cause any major performance issues on the computer running it either. There should be no impact on the performance of the actual test runs, since the tool is designed for offline test generation, where the tests are not executed during generation.

\subsubsection{Safety and security requirements}
This application will be able to post data into an online database, which includes some security risks. These should be handled with proper sanitation of the data on the server side as well as use of secure communications channels wherever possible.

\subsubsection{Software quality attributes}
The command line interface of the application should be designed to be simple and powerful and it should provide sufficient feedback and status reports to the users. Possible errors should be easily identified. The test cases generated by the tool should be human readable and should reflect the selection criteria, fulfilled requirements and the actual test case that the script implements.

\section{Proof of concept}
The first step in the process was to create a simple proof of concept application. This small prototype was designed to be a first step to get familiar with the problems and issues related to this application. This prototype was somewhat influenced by an earlier open-source MBT tool called OSMO MBT Tool, which is available in Github and which was suggested as something to study by the customer. \cite{OSMO}

The proof of concept was implemented using python and it implemented a very basic mbt-like functionality using class attributes equipped with decorators to denote test steps and guards. This prototype was able to generate sequences of random valid test steps into test cases and run those test cases.

\subsection{Lessons learned}
The very simplistic implementation and design of the first prototype already highlighted several issues related to the tool. Simple, random sequences of test steps, which only utilize data from sources, that are not related to test selection, are easy to generate, but once support for selection of input data is brought into the equation, things get more complicated. The second major issue that was brought up was the generation of oracles. All in all, the proof of concept application was a good exercise, which was useful in estimation of future work and the design of the next iteration of the application. 


\section{Design}

\section{Implementation}

\section{Testing}